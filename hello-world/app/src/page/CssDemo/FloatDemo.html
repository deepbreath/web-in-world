<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title> 
    <style>
        .green{
            width: 200px;
            height: 200px;
            background-color: yellowgreen;
        }
        .blue{
            width: 300px;
            height: 300px;
            background-color: skyblue;
        }
        .green1{
            float: left;
            width: 200px;
            height: 200px;
            background-color: yellowgreen;
        }
        .blue1{
            width: 300px;
            height: 300px;
            background-color: skyblue;
        }
        .green2{
            float: left;
            width: 300px;
            height: 300px;
            background-color: yellowgreen;
        }
        .blue2{
            float: right;
            width: 300px;
            height: 300px;
            background-color: skyblue;
        }
        .red2{
            float: right;
            width: 300px;
            height: 500px;
            background-color: red;
        }
        .green3{
            float: left;
            width: 300px;
            height: 300px;
            background-color: yellowgreen;
        }
        .green4{
            float: left;
            background-color: yellowgreen;
        }
        
       li{
            float: left;
            width: 100px;
            height: 100px;
            background-color: pink;
        }
        .box2{
            margin-top: 10px;
            clear: both;
        }
        .cl{
            clear: both;
        }
        .h16{
            height: 16px;
        }
        .box5{
            background-color: green;
        }
        .box5 p{
            float: left;
            width: 100px;
            height: 100px;
            background-color: red;
        }
        .box6{
            background-color: green;
        }
        .box6 p{
            float: right;
            width: 100px;
            height: 100px;
            background-color: red;
        }
        .box7{
            overflow: hidden;
            background-color: yellowgreen;
        }
    </style>
</head>
<body>
    <h3 style="text-align: center; color: tomato;">行内元素和块级元素</h3>
    <pre>
        行内元素和块级元素区别:
        行内元素: 
            与其他行内元素并排
            不能设置宽，高。默认的宽度，就是文字的宽度
        块级元素:
            霸占一行，不能与其他任何元素并列
            能接受宽，高。如果不设置宽高，那么宽度默认为父亲的100%
        行内元素和块级元素的分类:
        文本级别：p span a b i u em
        容器级别：div h系列 li dt dd
    PS: p标签只能存放文字&图片&表单元素,p 里面不能放 h 和 ul，p 里面也不能放p 

    行内元素: 出了 p 之外，所有的文本级标签，都是内行元素。p 是文本级，但是是一个块元素
    块级元素: 所有的容器标签都是块元素，还有 p 标签
    </pre>
    <h3 style="text-align: center; color: tomato;">行内元素和块元素的想换转换</h3>
    <pre>
        我们可以通过 display 属性将块级元素 和 行内元素进行相互转换。display 即 “显示模式”
        使用 display:inline 将块级转换为行级元素
        使用 display:block 将行级别转换为块级别
        CSS 中一共三种手段，使一个元素脱离标准文档流
        （1） 浮动
        （2） 绝对定位
        （3） 固定定位
        标准流中的文字不会被浮动的盒子盖住。（文字像水一样像四周印开）
        永远不是一个元素浮动，浮动后大家一起浮动的
        
    </pre> 
    <h3 style="text-align: center; color: tomato;">浮动的性质</h3>
    <fieldset>
        <legend>未使用浮动设置</legend>
        <div class="green"></div>
        <div class="blue"></div>
    </fieldset>

    <fieldset>
        <legend>性质1：浮动的元素脱标</legend>
        <div class="green1"></div>
        <div class="blue1"></div>
    </fieldset>

    <fieldset>
        <legend>性质2：浮动的元素互相贴靠</legend>
        <div class="green2"></div>
        <div class="blue2"></div>
        <div class="red2"></div>
    </fieldset>

    <fieldset>
        <legend>性质3：浮动的元素有“字围”效果</legend>
        <div class="green3"></div>
        <p>New business models are possible
In a world where anyone can fork a piece of software and make their own modifications to it, new business models might become popular.
It might look a lot more like the world of games where modding and customizations are quite common, and there are whole economies devoted to making and selling mods of popular games. In a world like this, rather than building a new app from scratch, individual developers or small teams might choose to start out with an already-existing app, fork it, and mod it for a niche to resell it.
Perhaps, whoever made the original version of the software could collect a cut of the revenue generated by any modded versions. Or, perhaps, they’d charge a services fee for use of the AI needed to customize the software—in the way SaaS companies charge large enterprises for custom integrations today.
There are significant challenges inherent in this model as well. 
        </p>
    </fieldset>

    <fieldset>
        <legend>性质4：收缩</legend>
        <div class="green4">收缩：一个浮动的元素，如果没有设置width，那么将自动收缩为内容的宽度（这点非常像行内元素）。</div>
    </fieldset>

    <h3 style="text-align: center;color: tomato;">浮动定位测试</h3>
    <a href="FloatDemoHomeWork.html">Demo</a>

    <h3 style="text-align: center; color: tomato;">浮动清除</h3>
    <pre>
        这里所说的清除浮动，指代清除浮动与浮动之间的影响
        浮动又开始，就有清除
    </pre>
    <fieldset>
        <legend>浮动的影响 Demo，两个无需列表应该是分开的，结果第二个紧紧跟着第一个</legend>
        <pre>
            方法1:
            问题原因: li 标签的父亲 div 没有设置高度，导致两个 div 的高度都是 0px
            解决方式: div 设置合适的高度，保证高度大于 儿子的高度
            总结:有高度的盒子，才能关住浮动
            如果一个元素要浮动，那么他的祖先元素一定要有高度

        </pre>
        <div class="list1">
            <ul>
                <li>列表1</li>
                <li>列表1</li>
                <li>列表1</li>
                <li>列表1</li>
            </ul>
        </div>
        <div class="list2">
            <ul>
                <li>列表2</li>
                <li>列表2</li>
                <li>列表2</li>
                <li>列表2</li>
            </ul>
        </div>
    </fieldset>
    <pre>
        方法2:clear:both;
        clear 清除，both指左浮动，右浮动都要清除。 clear:both 的意思就是
        不允许左侧和右侧有浮动对象
        问题:如果使用 它所在的标签 margin 属性会失效
    </pre>
    <fieldset>
        <legend>使用clear:both 清理浮动</legend>
        <div class="box1">
            <ul>
                <li>元素1</li>
                <li>元素1</li>
                <li>元素1</li>
                <li>元素1</li>
            </ul>
        </div>
        <div class="box2">
            <ul>
                <li>元素2</li>
                <li>元素2</li>
                <li>元素2</li>
                <li>元素2</li>
            </ul>
        </div>
    </fieldset>

    <h3 style="text-align: center;color:tomato;">方法3:隔墙法</h3>
    <fieldset>
        <legend>隔墙法</legend>
        <div class="box3">
            <ul>
                <li>元素4</li>
                <li>元素4</li>
                <li>元素4</li>
                <li>元素4</li>
            </ul>
        </div>
        <div class="cl h16"></div>
        <div class="box4">
            <ul>
                <li>元素5</li>
                <li>元素5</li>
                <li>元素5</li>
                <li>元素5</li>
                <li>元素5</li>
            </ul>
        </div>
    </fieldset>
    <fieldset>
        <legend>内墙法</legend>
        <p>两个 p 都是浮动，所以父亲 div 不能被撑出高。</p>
        <p>如果家里修建一堵墙，就能让 div 被 儿子撑出高度</p>
        <p>此时: div 可以自适应内容</p>
        <p>注意:一个父亲不能被浮动的的儿子撑出高度的</p>
        <p>与外墙相比，内墙方法的优势在于，内墙可以给所在容器撑出高度，box6 的高度可以自适应</p>
        <div class="box5">
            <p></p>
        </div>

        <div class="box6">
            <p></p>
            <div class="cl"></div>
        </div>
    </fieldset>
    <fieldset>
        <legend>overflow:hidden 生成BFC</legend>
        <div class="box7">
            <ul>
                <li>元素7</li>
                <li>元素7</li>
                <li>元素7</li>
                <li>元素7</li>
            </ul>
        </div>
        <div class="box8">
            <ul>
                <li>元素8</li>
                <li>元素8</li>
                <li>元素8</li>
                <li>元素8</li>
            </ul>
        </div>
    </fieldset>
    <fieldset>
        <legend>浮动清除总结</legend>
        <pre>
            浮动元素，只能被有高度的盒子关注，如果盒子内有浮动，且盒子有高则不会影响
            1. 加高方法，不建议使用麻烦，且无法适应页面的快速变化
            2.clear:both 最简单的清除浮动方法，但是会使 margin 外边距失效
            3.隔墙方法：两个浮动元素之间创建一个墙或者块，隔开两边浮动，然后面的浮动，不去追前面的
            浮动元素。墙用自己的身体当作间隙，缺点：无法将第一个 div 撑出高度
            4.内墙方法：允许后部分p，不去追前部分的p，并且可以吧第一个div 撑出高度
            5.overflow:hidden:推荐使用，一种偏方？并且可以让 margin 生效
        </pre>
    </fieldset>


</body>
</html>